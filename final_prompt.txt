AI Wardrobe Recommendation System – End to End)
 ROLE & GOAL
You are a senior full-stack engineer + ML engineer helping me build a personal AI wardrobe recommendation system.
The system should:
Analyze my photo (skin tone / undertone)Analyze my clothes photos (dominant color, clothing type)Store metadata in DBRecommend outfits based on:EventWeatherTime of dayColor compatibility with my skin toneThis is an MVP, optimized for:
SimplicityReadabilityFast developmentFree-tier hosting TECH STACK (STRICT)
Use ONLY the following unless explicitly told otherwise:
Backend: FastAPI (Python)Image Processing: OpenCV, NumPy, scikit-learnDatabase: PostgreSQL (Supabase-compatible)Image Storage: CloudinaryRecommendation Logic: Rule-based (no deep learning)Auth: None (single-user MVP) PROJECT STRUCTURE (MANDATORY)
Create code following this structure:
wardrobe-ai/
│
├── app/
│   ├── main.py
│   ├── config.py
│   ├── database.py
│   │
│   ├── models/
│   │   ├── user.py
│   │   ├── clothing.py
│   │
│   ├── schemas/
│   │   ├── user_schema.py
│   │   ├── clothing_schema.py
│   │
│   ├── services/
│   │   ├── image_service.py
│   │   ├── color_service.py
│   │   ├── skin_tone_service.py
│   │   ├── recommendation_service.py
│   │
│   ├── routes/
│   │   ├── user_routes.py
│   │   ├── clothing_routes.py
│   │   ├── recommendation_routes.py
│
├── requirements.txt
└── README.md
 USER IMAGE ANALYSIS REQUIREMENTS
When a user photo is uploaded:
Detect face (OpenCV Haar Cascade)Extract skin pixelsConvert image to LAB or HSV color spaceDetermine:Skin tone: FAIR | MEDIUM | DARKUndertone: WARM | COOL | NEUTRALStore results in DB.
 No deep learning. Use simple averaging + thresholds.
 CLOTHING IMAGE ANALYSIS REQUIREMENTS
When a clothing image is uploaded:
Resize image for performanceUse KMeans clustering to extract:Primary colorSecondary color (if exists)Convert colors to human-readable labels:BLACK, WHITE, BLUE, RED, BEIGE, etc.Store:image_url (Cloudinary)dominant_colorclothing_type (SHIRT, TSHIRT, JEANS, KURTA, etc.)occasion (CASUAL, OFFICE, PARTY, TRADITIONAL)season (SUMMER, WINTER, ALL)Clothing type & occasion can be manual input in API for MVP.
 RECOMMENDATION ENGINE RULES
Implement rule-based scoring, NOT ML.
Example logic:
score = 0
IF event == clothing.occasion → +3
IF weather == HOT and color in light_colors → +2
IF skin_tone == DARK and color in bright_colors → +2
IF skin_undertone == WARM and color in warm_palette → +2
IF time == NIGHT and color == BLACK → +1
Return top 3 outfits sorted by score.
 INPUT PARAMETERS FOR RECOMMENDATION API
API should accept:
event (OFFICE, CASUAL, PARTY, WEDDING)weather (HOT, COLD, RAINY)time_of_day (DAY, NIGHT) API ENDPOINTS (REQUIRED)
User
POST /user/upload-photoGET /user/profileClothing
POST /clothing/uploadGET /clothing/allRecommendation
POST /recommendation/suggest CODE QUALITY RULES
No inline lambdasNo magic numbersUse enums where applicableWrite clean, interview-ready codeAdd comments explaining WHY, not WHAT DEPLOYMENT ASSUMPTIONS
App must be compatible with Render free tierDB must work with Supabase PostgresImages must use Cloudinary URLsNo local filesystem dependency in prod README REQUIREMENTS
Include:
Project overviewArchitecture diagram (text-based)How color analysis worksHow recommendation logic worksFree-tier deployment explanation DO NOT
Do NOT use deep learningDo NOT over-engineerDo NOT skip error handlingDo NOT invent user authDo NOT optimize prematurely FINAL GOAL
At the end, I should have:
A running FastAPI appAbility to upload my photoUpload clothes photosSelect an eventGet outfit suggestionsBuild step-by-step, file-by-file.
Wait for confirmation before moving to next major module.
 START BY:
Creating requirements.txtCreating main.pySetting up DB connection END OF PROMPT 
How to use this in Cursor (important)
Paste this promptSay:“Start with requirements.txt and main.py”
Then iterate module by moduleIf you want, next I can:
Split this into Cursor micro-promptsGive you a 12-hour execution checklistConvert this into LLD interview explanationJust tell me 
[2:21 PM]Yesss — great instinct 
This is exactly how you turn a working project into an interview-grade, reviewer-approved codebase.
Below is a drop-in ADDITIONAL PROMPT you can append at the end of your existing Cursor master prompt.
Do not replace anything — just paste this under it.
 ADDITIONAL CURSOR PROMPT
Coding Standards, Quality & Maintainability (MANDATORY)
 GENERAL CODING PRINCIPLES (STRICT)
Follow production-grade Python standards at all times:
Follow PEP8 formatting strictlyMax line length: 88 charactersUse explicit variable names (no x, tmp, data1)One responsibility per functionFunctions should be short and testablePrefer clarity over cleverness STRUCTURAL RULES
 No God Classes
Each service must handle exactly one concernImage processing, color extraction, skin tone logic must be separated No Magic Values
All constants must be declared in:app/constants/
Example:
color thresholdsscore weightssupported events Enums Everywhere
Use enums for:
EventTypeWeatherTypeTimeOfDaySkinToneSkinUndertoneClothingTypeOccasionTypeSeasonTypeDo not use raw strings in business logic.
 FUNCTION DESIGN RULES
Every function must:
Do one thingBe named like a sentence:extract_dominant_colorsclassify_skin_undertoneHave type hintsHave a docstring explaining why it existsExample:
def classify_skin_undertone(lab_values: np.ndarray) -> SkinUndertone:
    """
    Determines skin undertone based on LAB color distribution
    to improve outfit color compatibility.
    """
 ERROR HANDLING (MANDATORY)
Never return None silentlyRaise custom exceptions:app/exceptions/
Examples:
ImageProcessingErrorInvalidClothingMetadataErrorRecommendationInputErrorAll API routes must:
Catch domain exceptionsReturn meaningful HTTP errors TESTABILITY REQUIREMENTS
Code must be written so that:
Core logic can be tested without FastAPIServices do not depend on request/response objectsPure functions are preferred where possible LOGGING (NOT PRINT)
Use Python loggingLog:Image upload success/failureRecommendation scoring decisionsNever use print() COMMENTS & DOCSTRINGS
Avoid obvious commentsExplain:Why thresholds existWhy certain colors match skin tonesAll public methods must have docstrings STYLE CONSISTENCY
No inline lambdasNo nested ternary operatorsNo long if-else chains → extract helper functionsFollow consistent naming across layers:*_service.py*_routes.py*_schema.py ITERATIVE DEVELOPMENT RULE
After finishing each file:
Validate importsCheck for unused codeEnsure file passes flake8 style rules (conceptually) FINAL EXPECTATION
At the end:
Code should feel reviewed by a senior engineerAny file should be explainable in an interviewNo “just works” hacksNo rushed shortcutsIf any design decision is ambiguous:
→ Choose the simplest readable option and explain it in comments.
 END OF CODING STANDARDS PROMPT